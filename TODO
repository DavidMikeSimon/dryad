- Allow optional use of a development mode which:
  - Makes sure all attribute keys are valid in XML
  - Makes sure all tags are valid in XML
  - In the HTML taglib, checks attributes for tag-specific validity
  - Flags attempts to use tag return values with helpful error messages
  - Flags useless defs (i.e. like in custom_tag_tests.rb test_indef_redef_with_run sans the run)
  - Flags dangerous permanent redefs (i.e. like in custom_tag_tests.rb test_inblock_redef_with_run sans the run)
  - Flags attempts to use puts
  - Flags attempts to call tag methods within a running block; this will not do anything useful
  - Applies NearMissSuggestions to regular method_missing (so, remove this from the regular dryad.rb where it is now)
  - Makes sure output is not written during running block (also needs to be removed from regular dryad.rb where it is
    now)
  - Freezes AttributesHash after setup (again move from current dryad.rb)
  - Warns if 'content' method is given a non-bang-ending symbol
  - Does not cause a performance hit if not in use (use monkey-patches, not lots of ifs)
- Add methods like dryml's before, after, prepend, append stuff
  - Have some sort of general-purpose matching system for this, detecting tag name, class, id, parent, etc.
  - Maybe based on a subset of CSS selector syntax?
- Polymorphic tag definitions (different definitions at the same layer that apply depending upon argument type)
  - Given a plain ol' value, is there some way to tell where it came from, i.e. some column of some model?
- Instance variables
  - Possibly frozen in subcontexts so that I don't have to worry about cloning
  - Er, can one freeze a "view" of an object but leave the original mutable?
  - And anyways, it seems like freezing something (i.e. an array) doesn't prevent its contents from being changed
- Test that one tag-defining module can depend on another, and that including the base manually after that won't
  overwrite the child definitions

- Make everything tag-class-oriented:
  - Advantages: very easy to mess with CSS, and to re-specify/re-define stuff by semantics instead of conceptually
    distant things like whether it's a div or a span
  - Should probably make class shortcuts regular symbols (no bang-appends) so bang-appends can be used for special stuff
  - Get rid of yields, don't pass blocks to tag definitions
  - Regular content block (whether passed by simple sub-block of tag call or through 'content' in running) to be made
    the regular content of the tag with the :content! modifier, which trickles down until we get to a raw_tag
      - Implies that raw_tag needs to be kind of special, not just another tag; would be nice if it were still modular
      - Need to complain if content block is passed to a tag that doesn't have a :content! marked tag within it
      - Should give the :content! tag a real tag class based on method name, i.e. :content! in def card gets class
        "card-content"
      - Want to have content be appended to some stuff within a tag, i.e. "<p><div>FOO BAR</div>(content here)</p>"?
        Best probably to suck it up and just put it in a span, or if you really need it do a prepend.
  - To make everything classier (heh) should also probably make the first raw_tag within a tag definition get the same
    class as the method name (i.e. if "def card" is "p { v'whateva' }" gets me a "<p class='card'>whateva</p>")
    - If additional classes are specified, still prepend the magical method-name class
    - When doing polymorphism, also add a magic tag class for that, i.e. "<p class='card card-for-appointment'>"
    - If the first raw_tag is so special, maybe should disallow more than one major raw_tag call per method?
      - Or maybe should just get rid of def syntax and create a tag_def that's always based on an upper tag?
        - This would get rid of default arguments, but I can't think of any other significant disadvantage...
        - Advantages: would let user create regular utility methods (like helper methods), would possibly let me get rid
          of a lot of the more magical junk (i.e. can get rid of hybrid eval, and don't need to worry about super anymore)
        - Need to think about how parent tag gets attributes from child tag call

- In Context should probably rename 'running' to 'oneoff', and 'run' to something like 'oneoff_block'
  - This is handy because it implies that it's like defining a child tag, but without having to seperate def and call,
    which is just the idiom I'm going for
- If getting rid of default arguments, might be able to compensate with convenience functions in AttributesHash
  - Maybe an easy-subset thing (i.e. attributes[[:attr1, :attr2, :attr3]]) for passing on attributes
  - To set default values, can just use attributes[:attr] ||= whatever
